package TA_Report_Tool.Data;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.concurrent.ExecutionException;

import TA_Report_Tool.MainApp.ExceptionsPack;
import TA_Report_Tool.MainApp.ExceptionsPack.cantBeParsedWithCurrentMappingMask;
import TA_Report_Tool.MainApp.ExceptionsPack.columnPropertiesDoesNotExist;
import TA_Report_Tool.MainApp.ExceptionsPack.connectionNotInitialized;
import TA_Report_Tool.MainApp.ExceptionsPack.dateOrTimeMissing;
import TA_Report_Tool.MainApp.ExceptionsPack.nullArgument;
import TA_Report_Tool.MainApp.ExceptionsPack.nullColumnPropertiesPassed;
import TA_Report_Tool.MainApp.ExceptionsPack.nullDataReceivedForParsing;
import TA_Report_Tool.MainApp.ExceptionsPack.parsingFailedDueToNullMappingMask;
import TA_Report_Tool.MainApp.ExceptionsPack.rowParameterNotHigherThanZero;
import TA_Report_Tool.MainApp.ExceptionsPack.tableDataNotInitialized;
import TA_Report_Tool.MainApp.ExceptionsPack.tableLengthAndDataLengthNotMatching;
import TA_Report_Tool.Processors.ContentParserByMappingUnit;
import TA_Report_Tool.Tools.check;

public class TableData {

	private ArrayList<ColumnData<?>> columnsDataStorage = new ArrayList<ColumnData<?>>();
	private ColumnData<LocalDateTime> dateTimeColumn;
	private int rowCount = 0;
	private ArrayList<ColumnProperties> listOfColumnProperties;

	private boolean initializeFlag = false;

	/**
	 * Constructor of TableData object, used to emulate a table (header and columns
	 * of data) and store the Time And Attendance data
	 * <p>
	 * <b>IMPORTANT</b>: the creation of a new TableData object, does not prepare
	 * the structure to store data yet. <code>initializeTableData</code> needs to be
	 * called to create the storage structure and this is called each time the
	 * results of a new Header Column Scan is available
	 * 
	 * 
	 * @param tableHeader of <i><code>TableHeader</code></i> type that contains all
	 *                    parameters and properties of columns.
	 * @throws InterruptedException
	 * @throws ExecutionException
	 * @throws connectionNotInitialized
	 * @throws dateOrTimeMissing
	 * @throws nullArgument
	 */
	public void initializeTableData(ArrayList<ColumnProperties> listOfColumnProperties)
			throws InterruptedException, ExecutionException, connectionNotInitialized, dateOrTimeMissing, nullArgument {
		this.initializeFlag = true;
		this.listOfColumnProperties = listOfColumnProperties;

		if (!hasDateAndTime()) {
			throw new ExceptionsPack.dateOrTimeMissing("Date or Time Column properties is missing from TableHeader");
		}

		for (ColumnProperties currentColumn : this.listOfColumnProperties) {
			if (currentColumn.loadData()) {
				this.columnsDataStorage.add(new ColumnData<>(currentColumn));
			} else {
				this.columnsDataStorage.add(null);
			}
		}

		this.dateTimeColumn = new ColumnData<>(new ColumnProperties("AutoGenerated Date & Time", true,
				new MappingUnit("AutoGenerated Date & Time",
						new MaskTemplate().addDay().addSep(".").addMonth().addSep(".").addYYYYear().addSep(" ")
								.addminute().addSep(":").addhour().addSep(":").addsecond().addSep(" ").markAMPMTime(),
						MappingType.DateAndTime),
				0));
	}

	public void parseAndStoreOneDataRow(String[] arrayRowOfDataUnparsed)
			throws tableLengthAndDataLengthNotMatching, nullDataReceivedForParsing, InterruptedException,
			ExecutionException, connectionNotInitialized, nullColumnPropertiesPassed, columnPropertiesDoesNotExist,
			cantBeParsedWithCurrentMappingMask, parsingFailedDueToNullMappingMask, rowParameterNotHigherThanZero,
			tableDataNotInitialized, dateOrTimeMissing, nullArgument {
		if (this.initializeFlag == false) {
			throw new ExceptionsPack.tableDataNotInitialized(
					"Parse string array and store, can't be processed as TableData was not initialized. TableData is initialized upon Table header scan");
		}

		if (!isSameLengthAsTable(arrayRowOfDataUnparsed)) {
			throw new ExceptionsPack.tableLengthAndDataLengthNotMatching(
					"The array received for parsing, has different length than table length");
		}

		if (arrayRowOfDataUnparsed == null) {
			throw new ExceptionsPack.nullDataReceivedForParsing("");
		}

		parseAndStoreRow(arrayRowOfDataUnparsed);
	}

	private void parseAndStoreRow(String[] arrayRowOfDataUnparsed)
			throws InterruptedException, ExecutionException, connectionNotInitialized, nullColumnPropertiesPassed,
			columnPropertiesDoesNotExist, cantBeParsedWithCurrentMappingMask, parsingFailedDueToNullMappingMask,
			rowParameterNotHigherThanZero, dateOrTimeMissing, nullArgument {

		ArrayList<ColumnProperties> listOfAllColsProperties = this.listOfColumnProperties;
		ColumnProperties currentColumn = null;

		for (int i = 0; i < listOfAllColsProperties.size(); i++) {
			currentColumn = listOfAllColsProperties.get(i);

			if (currentColumn.loadData()) {
				this.columnsDataStorage.get(i).addData(new ContentParserByMappingUnit<>(this.listOfColumnProperties)
						.parse(arrayRowOfDataUnparsed[i], currentColumn.getName()));
			}
		}
		this.rowCount++;

		parseDateAndTime();
	}

	private void parseDateAndTime()
			throws rowParameterNotHigherThanZero, InterruptedException, ExecutionException, connectionNotInitialized {
		LocalTime localTime = null;
		LocalDate localDate = null;
		LocalDateTime localDateTime = null;

		ArrayList<ColumnProperties> listOfAllColsProperties = this.listOfColumnProperties;
		ColumnProperties currentColumn = null;

		for (int i = 0; i < listOfAllColsProperties.size(); i++) {
			currentColumn = listOfAllColsProperties.get(i);

			switch (currentColumn.getMappingUnit().getType()) {
			case Time:
				localTime = (LocalTime) this.columnsDataStorage.get(i).getDataAt(rowCount);
				break;
			case Date:
				localDate = (LocalDate) this.columnsDataStorage.get(i).getDataAt(rowCount);
				break;
			case DateAndTime:
				localDateTime = (LocalDateTime) this.columnsDataStorage.get(i).getDataAt(rowCount);
				break;
			default:
				break;
			}
		}

		if (!check.isNull(localDateTime)) {
			this.dateTimeColumn.addData(localDateTime);
		} else {
			this.dateTimeColumn.addData(LocalDateTime.of(localDate, localTime));
		}

	}

	public int getRowCount() throws tableDataNotInitialized {
		if (this.initializeFlag == false) {
			throw new ExceptionsPack.tableDataNotInitialized(
					"Parse string array and store, can't be processed as TableData was not initialized. TableData is initialized upon Table header scan");
		}
		return this.rowCount;
	}

	private boolean isSameLengthAsTable(String[] arrayRowOfDataUnparsed)
			throws InterruptedException, ExecutionException, connectionNotInitialized, tableDataNotInitialized {
		if (this.initializeFlag == false) {
			throw new ExceptionsPack.tableDataNotInitialized(
					"Parse string array and store, can't be processed as TableData was not initialized. TableData is initialized upon Table header scan");
		}
		int lengthOfPassedArray = arrayRowOfDataUnparsed.length;
		int lengthOfStoredTableHeader = this.listOfColumnProperties.size();

		if (lengthOfPassedArray == lengthOfStoredTableHeader) {
			return true;
		}
		return false;
	}

	private boolean hasDateAndTime() {
		boolean dateFlag = false;
		boolean timeFlag = false;

		for (ColumnProperties x : this.listOfColumnProperties) {
			if (x.getMappingUnit().getType() == MappingType.Date) {
				dateFlag = true;
			}

			if (x.getMappingUnit().getType() == MappingType.DateAndTime) {
				dateFlag = true;
				timeFlag = true;
			}

			if (x.getMappingUnit().getType() == MappingType.Time) {
				timeFlag = true;
			}

			if (dateFlag && timeFlag) {
				return true;
			}
		}
		return false;
	}
}
