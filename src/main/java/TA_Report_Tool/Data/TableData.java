package TA_Report_Tool.Data;

import static TA_Report_Tool.Tools.check.isFalse;
import static TA_Report_Tool.Tools.debug.*;
import static TA_Report_Tool.Tools.check.isNotNull;
import static TA_Report_Tool.Tools.check.isNull;
import static TA_Report_Tool.Tools.check.isZero;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.concurrent.ExecutionException;

import TA_Report_Tool.Filters.StdFilter;
import TA_Report_Tool.Filters.TAfiltersAndSettings;
import TA_Report_Tool.MainApp.ExceptionsPack;
import TA_Report_Tool.MainApp.ExceptionsPack.cantBeParsedWithCurrentMappingMask;
import TA_Report_Tool.MainApp.ExceptionsPack.cantParseEmptyStringForCurrentType;
import TA_Report_Tool.MainApp.ExceptionsPack.columnPropertiesDoesNotExist;
import TA_Report_Tool.MainApp.ExceptionsPack.connectionNotInitialized;
import TA_Report_Tool.MainApp.ExceptionsPack.dateOrTimeMissing;
import TA_Report_Tool.MainApp.ExceptionsPack.nullArgument;
import TA_Report_Tool.MainApp.ExceptionsPack.nullColumnPropertiesPassed;
import TA_Report_Tool.MainApp.ExceptionsPack.nullDataReceivedForParsing;
import TA_Report_Tool.MainApp.ExceptionsPack.parsingFailedDueToNullMappingMask;
import TA_Report_Tool.MainApp.ExceptionsPack.rowParameterNotHigherThanZero;
import TA_Report_Tool.MainApp.ExceptionsPack.tableDataNotInitialized;
import TA_Report_Tool.MainApp.ExceptionsPack.tableLengthAndDataLengthNotMatching;
import TA_Report_Tool.Processors.ContentParserByMappingUnit;
import TA_Report_Tool.Tools.TableDisplay;

public class TableData {

	private ArrayList<ColumnData> columnsDataStorage;
	private ColumnData dateTimeColumn;
	private int rowCount;
	private ArrayList<ColumnProperties> listOfColumnProperties;

	private boolean initializeFlag;

	public TableData() {
		this.columnsDataStorage = new ArrayList<ColumnData>();
		this.dateTimeColumn = null;
		this.rowCount = 0;
		this.listOfColumnProperties = null;
		this.initializeFlag = false;
	}

	/**
	 * Constructor of TableData object, used to emulate a table (header and columns
	 * of data) and store the Time And Attendance data
	 * <p>
	 * <b>IMPORTANT</b>: the creation of a new TableData object, does not prepare
	 * the structure to store data yet. <code>initializeTableData</code> needs to be
	 * called to create the storage structure and this is called each time the
	 * results of a new Header Column Scan is available
	 * 
	 * 
	 * @param tableHeader of <i><code>TableHeader</code></i> type that contains all
	 *                    parameters and properties of columns.
	 * @throws InterruptedException
	 * @throws ExecutionException
	 * @throws connectionNotInitialized
	 * @throws dateOrTimeMissing
	 * @throws nullArgument
	 */
	public void initializeTableData(ArrayList<ColumnProperties> listOfColumnProperties)
			throws InterruptedException, ExecutionException, connectionNotInitialized, dateOrTimeMissing, nullArgument {
		this.initializeFlag = true;
		this.listOfColumnProperties = listOfColumnProperties;

		for (ColumnProperties currentColumn : this.listOfColumnProperties) {
			if (currentColumn.loadData()) {
				this.columnsDataStorage.add(new ColumnData(currentColumn));
			} else {
				this.columnsDataStorage.add(null);
			}
		}

		this.dateTimeColumn = new ColumnData(new ColumnProperties("AutoGenerated Date & Time", true,
				new MappingUnit("AutoGenerated Date & Time",
						new MaskTemplate().addDay().addSep(".").addMonth().addSep(".").addYYYYear().addSep(" ")
								.addminute().addSep(":").addhour().addSep(":").addsecond().addSep(" ").markAMPMTime(),
						MappingType.DateAndTime),
				0));
	}

	protected ArrayList<ColumnProperties> getListOfColumnProperties() {
		return this.listOfColumnProperties;
	}

	public void parseAndStoreOneDataRow(String[] arrayRowOfDataUnparsed)
			throws tableLengthAndDataLengthNotMatching, nullDataReceivedForParsing, InterruptedException,
			ExecutionException, connectionNotInitialized, nullColumnPropertiesPassed, columnPropertiesDoesNotExist,
			cantBeParsedWithCurrentMappingMask, parsingFailedDueToNullMappingMask, rowParameterNotHigherThanZero,
			tableDataNotInitialized, dateOrTimeMissing, nullArgument, cantParseEmptyStringForCurrentType {

		if (isFalse(isInitialized())) {
			throw new ExceptionsPack.tableDataNotInitialized(
					"Parse string array and store, can't be processed as TableData was not initialized. TableData is initialized upon Table header scan");
		}

		if (isFalse(hasDateAndTime())) {
			throw new ExceptionsPack.dateOrTimeMissing("Date or Time Column properties is missing from TableHeader");
		}

		if (isFalse(isSameLengthAsTable(arrayRowOfDataUnparsed))) {
			throw new ExceptionsPack.tableLengthAndDataLengthNotMatching(
					"The array received for parsing, has different length than table length. The header table is "
							+ this.listOfColumnProperties.size()
							+ " columns long and the array received for parsing is " + arrayRowOfDataUnparsed.length);
		}

		if (isNull(arrayRowOfDataUnparsed)) {
			throw new ExceptionsPack.nullDataReceivedForParsing("");
		}

		parseAndStoreRow(arrayRowOfDataUnparsed);
	}

	public boolean isInitialized() {
		if (this.initializeFlag) {
			return true;
		}
		return false;
	}

	public int getRowCount() throws tableDataNotInitialized {
		if (isFalse(isInitialized())) {
			throw new ExceptionsPack.tableDataNotInitialized(
					"Parse string array and store, can't be processed as TableData was not initialized. TableData is initialized upon Table header scan");
		}
		return this.rowCount;
	}

	public boolean containsColumnWithMappingUnit(MappingUnit maapingUnitToBeSearched) {
		for (ColumnData x : this.columnsDataStorage) {
			if (x.getColumnMappingUnit() == maapingUnitToBeSearched) {
				return true;
			}
		}
		return false;
	}

	public boolean containsColumnWithMappingType(MappingType maapingTypeToBeSearched) {
		for (ColumnData x : this.columnsDataStorage) {
			if (x.getColumnMappingUnit().getType() == maapingTypeToBeSearched) {
				return true;
			}
		}
		return false;
	}

	public void displayColumnPropertiesForDebugging() {
		TableDisplay tDisp = new TableDisplay();

		tDisp.add("Column Header Index");
		tDisp.add("Column Name");
		tDisp.add("Mapp. Unit Name");
		tDisp.add("Mapp. Unit Type");
		tDisp.newDispRow();

		if (isInitialized()) {
			for (ColumnData x : this.columnsDataStorage) {
				tDisp.add(x.getColumnHeaderIndex());
				tDisp.add(x.getColumnName());
				tDisp.add(x.getColumnMappingUnit().getName());
				tDisp.add(x.getColumnMappingUnit().getType());
				if (x != columnsDataStorage.get(columnsDataStorage.size() - 1)) {
					tDisp.newDispRow();
				}
			}
		}
		tDisp.display();
	}

	public void displayTableContentForDebugging() throws tableDataNotInitialized, rowParameterNotHigherThanZero {
		TableDisplay tDisp = new TableDisplay();

		if (isInitialized()) {
			int i = this.getRowCount();

			for (ColumnData x : this.columnsDataStorage) {
				tDisp.add(x.getColumnName());
			}

			for (int j = 1; j <= i; j++) {
				tDisp.newDispRow();
				for (ColumnData x : this.columnsDataStorage) {
					tDisp.add(x.getDataAt(j));
				}
			}
		}
		tDisp.display();
	}

	private void parseAndStoreRow(String[] arrayRowOfDataUnparsed)
			throws InterruptedException, ExecutionException, connectionNotInitialized, nullColumnPropertiesPassed,
			columnPropertiesDoesNotExist, cantBeParsedWithCurrentMappingMask, parsingFailedDueToNullMappingMask,
			rowParameterNotHigherThanZero, dateOrTimeMissing, nullArgument, cantParseEmptyStringForCurrentType {

		ArrayList<ColumnProperties> listOfAllColsProperties = this.listOfColumnProperties;
		ColumnProperties currentColumn = null;

		for (int i = 0; i < listOfAllColsProperties.size(); i++) {
			currentColumn = listOfAllColsProperties.get(i);
			if (currentColumn.loadData()) {
				this.columnsDataStorage.get(i).addData(new ContentParserByMappingUnit<>(this.listOfColumnProperties)
						.parse(arrayRowOfDataUnparsed[i], currentColumn.getName()));
			}
		}
		this.rowCount++;

		parseDateAndTime();
	}

	private void parseDateAndTime()
			throws rowParameterNotHigherThanZero, InterruptedException, ExecutionException, connectionNotInitialized {
		LocalTime localTime = null;
		LocalDate localDate = null;
		LocalDateTime localDateTime = null;

		ArrayList<ColumnProperties> listOfAllColsProperties = this.listOfColumnProperties;
		ColumnProperties currentColumn = null;

		for (int i = 0; i < listOfAllColsProperties.size(); i++) {
			currentColumn = listOfAllColsProperties.get(i);

			switch (currentColumn.getMappingUnit().getType()) {
			case Time:
				localTime = (LocalTime) this.columnsDataStorage.get(i).getDataAt(rowCount);
				break;
			case Date:
				localDate = (LocalDate) this.columnsDataStorage.get(i).getDataAt(rowCount);
				break;
			case DateAndTime:
				localDateTime = (LocalDateTime) this.columnsDataStorage.get(i).getDataAt(rowCount);
				break;
			default:
				break;
			}
		}

		if (isNotNull(localDateTime)) {
			this.dateTimeColumn.addData(localDateTime);
		} else {
			this.dateTimeColumn.addData(LocalDateTime.of(localDate, localTime));
		}

	}

	private boolean isSameLengthAsTable(String[] arrayRowOfDataUnparsed)
			throws InterruptedException, ExecutionException, connectionNotInitialized, tableDataNotInitialized {
		if (isFalse(isInitialized())) {
			throw new ExceptionsPack.tableDataNotInitialized(
					"Parse string array and store, can't be processed as TableData was not initialized. TableData is initialized upon Table header scan");
		}
		int lengthOfPassedArray = arrayRowOfDataUnparsed.length;
		int lengthOfStoredTableHeader = this.listOfColumnProperties.size();

		if (lengthOfPassedArray == lengthOfStoredTableHeader) {
			return true;
		}
		return false;
	}

	private boolean hasDateAndTime() {
		boolean dateFlag = false;
		boolean timeFlag = false;

		for (ColumnProperties x : this.listOfColumnProperties) {
			if (x.getMappingUnit().getType() == MappingType.Date) {
				dateFlag = true;
			}

			if (x.getMappingUnit().getType() == MappingType.DateAndTime) {
				dateFlag = true;
				timeFlag = true;
			}

			if (x.getMappingUnit().getType() == MappingType.Time) {
				timeFlag = true;
			}

			if (dateFlag && timeFlag) {
				return true;
			}
		}
		return false;
	}

	public LocalDateTime getDateTimeOfRow(int rowNumber) throws rowParameterNotHigherThanZero, tableDataNotInitialized {
		if (isFalse(isInitialized())) {
			throw new ExceptionsPack.tableDataNotInitialized(
					"Parse string array and store, can't be processed as TableData was not initialized. TableData is initialized upon Table header scan");
		}

		return (LocalDateTime) this.dateTimeColumn.getDataAt(rowNumber);
	}

	/**
	 * The method returns the data of a specific column, stored at row. The first
	 * row of the table is row 1.
	 * 
	 * @param columnName string containing the column name from the table header
	 * @param row        the table data row to be returned
	 * @return an object casted into the correct data type based on column type
	 * @throws rowParameterNotHigherThanZero
	 */
	public Object getDataOfColAtRow(String columnName, int row) throws rowParameterNotHigherThanZero {
		for (ColumnData currentColumn : this.columnsDataStorage) {
			if (currentColumn.getColumnName().equals(columnName)) {
				switch (currentColumn.getColumnMappingUnit().getType()) {
				case Date:
					return (LocalDate) currentColumn.getDataAt(row);
				case DateAndTime:
					return (LocalDateTime) currentColumn.getDataAt(row);
				case Time:
					return (LocalTime) currentColumn.getDataAt(row);
				case EmployeeFirstName:
				case EmployeeFullName:
				case EmployeeLastName:
				case EmployeeMiddleName:
				case EmployeeUniqueId:
				case Event:
				case SignalingDevice:
				case CustomFieldText:
				case NotSet:
					return (String) currentColumn.getDataAt(row);
				case FixedDigitNumber:
				case Number:
					return (Integer) currentColumn.getDataAt(row);
				}
			}
		}
		return null;
	}

	public Object[] getDataOfCol(String columnName) throws rowParameterNotHigherThanZero {
		for (ColumnData currentColumn : this.columnsDataStorage) {
			if (currentColumn.getColumnName().equals(columnName)) {
				switch (currentColumn.getColumnMappingUnit().getType()) {
				case Date:
					ArrayList<LocalDate> tempList = new ArrayList<>();
					for (int row = 1; row <= this.rowCount; row++) {
						tempList.add((LocalDate) currentColumn.getDataAt(row));
					}
					return tempList.toArray(new LocalDate[0]);
				case DateAndTime:
					ArrayList<LocalDateTime> tempList1 = new ArrayList<>();
					for (int row = 1; row <= this.rowCount; row++) {
						tempList1.add((LocalDateTime) currentColumn.getDataAt(row));
					}
					return tempList1.toArray(new LocalDateTime[0]);
				case Time:
					ArrayList<LocalTime> tempList2 = new ArrayList<>();
					for (int row = 1; row <= this.rowCount; row++) {
						tempList2.add((LocalTime) currentColumn.getDataAt(row));
					}
					return tempList2.toArray(new LocalTime[0]);
				case EmployeeFirstName:
				case EmployeeFullName:
				case EmployeeLastName:
				case EmployeeMiddleName:
				case EmployeeUniqueId:
				case Event:
				case SignalingDevice:
				case CustomFieldText:
				case NotSet:
					ArrayList<String> tempList3 = new ArrayList<>();
					for (int row = 1; row <= this.rowCount; row++) {
						tempList3.add((String) currentColumn.getDataAt(row));
					}
					return tempList3.toArray(new String[0]);
				case FixedDigitNumber:
				case Number:
					ArrayList<Integer> tempList4 = new ArrayList<>();
					for (int row = 1; row <= this.rowCount; row++) {
						tempList4.add((Integer) currentColumn.getDataAt(row));
					}
					return tempList4.toArray(new Integer[0]);
				}
			}
		}
		return null;
	}

	public String[] rowToArrayExceptDateAndTime(int row) throws rowParameterNotHigherThanZero {
		ArrayList<String> temp = new ArrayList<>();

		for (ColumnData currentColumn : this.columnsDataStorage) {
			MappingType type = currentColumn.getColumnMappingUnit().getType();
			if ((type != MappingType.Date) && (type != MappingType.Time) && (type != MappingType.DateAndTime)) {
				temp.add(String.valueOf(currentColumn.getDataAt(row)));
			}
		}

		return temp.toArray(new String[0]);
	}

	public void copyStructureFrom(TableData sourceTableData)
			throws InterruptedException, ExecutionException, connectionNotInitialized, dateOrTimeMissing, nullArgument {
		if (isFalse(sourceTableData.isInitialized())) {
			return;
		}

		this.initializeTableData(sourceTableData.getListOfColumnProperties());
	}

	public boolean passFiltersAtRow(int i, TAfiltersAndSettings localFiltersAndSettings) throws rowParameterNotHigherThanZero {
		display(this.getClass().getSimpleName(), "Analyzing filters pass of row " + i);

		if (isFalse(this.isInitialized())) {
			display(this.getClass().getSimpleName(), "Table Data is not initialized");
			return false;
		}

		if (isFalse(localFiltersAndSettings.dateTime()
				.passDateTimeFilter((LocalDateTime) this.dateTimeColumn.getDataAt(i)))) {
			display(this.getClass().getSimpleName(), "Date Time Filter was not passed");
			return false;
		}

		for (ColumnData x : this.columnsDataStorage) {
			ColumnData temp = x;
			StdFilter currentFilter = localFiltersAndSettings.getFilterForColumn(temp.getColumnName());

			if (isNotNull(currentFilter) && isFalse(currentFilter.passFilterCriterias(temp.getDataAt(i)))) {
				display(this.getClass().getSimpleName(),
						"The filter for column " + temp.getColumnName() + " did not passed at row " + i);
				return false;
			}
			display(this.getClass().getSimpleName(), "Column " + temp.getColumnName() + " filters passed");
		}
		return true;
	}

	public void copyDataRowFrom(int i, TableData sourceTableData) throws rowParameterNotHigherThanZero {
		TableData destinationTableData = this;
		for (ColumnData currentColumn : destinationTableData.columnsDataStorage) {
			currentColumn.addData(sourceTableData.getDataOfColAtRow(currentColumn.getColumnName(), i));
		}
		this.rowCount++;
	}
}
